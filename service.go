package apperix

import (
	"fmt"
	"time"
	"sync"
	"net/http"
	"database/sql"
	"github.com/golang/crypto/bcrypt"
)

/*
	The TargetUser type represents an enumeration of special users like:
	OTHERS and GUESTS. Just like certain user identifiers these special users
	can be used for identification.
*/
type TargetUser int
const (
	OTHERS TargetUser = iota
	GUESTS
)

/*
	The internal configuration provides
	read only configuration data through methods.
*/
type configuration struct {
	name string

	https bool
	certificate []byte
	privateKey []byte

	authConfig AuthenticationConfig
	networkConfig NetworkConfig
	defaultsConfig DefaultsConfig
}

/*
	Name returns the service name
*/
func (config *configuration) Name() string {
	return config.name
}

/*
	AccessTokenLiveTime returns the duration of time an access token
	generated by the service is valid for.
*/
func (config *configuration) AccessTokenLiveTime() time.Duration {
	return config.authConfig.TokenExpiry
}

/*
	?
*/
func (config *configuration) JwtSignatureSecret() []byte {
	return []byte(config.authConfig.SignatureSecret)
}

/*
	verifyTargetUser is used to verify the data type of a user argument.
	Arguments of unsupported types will cause panic!
*/
func verifyTargetUser(user interface{}) (userId string) {
	switch user.(type) {
	case *Identifier:
		identifier := user.(*Identifier)
		userId = identifier.String()
	case Identifier:
		identifier := user.(Identifier)
		userId = identifier.String()
	case TargetUser:
		switch(user) {
		case OTHERS:
			userId = "o"
		case GUESTS:
			userId = "g"
		}
	default:
		panic(fmt.Errorf("Invalid target user type: %s", user))
	}
	return userId
}

/*
	The Service type represents an actual apperix service.
*/
type Service struct {
	Config configuration
	database *sql.DB
	shutdownSignal chan int
	shutdownRequested bool
	reqsInProcess uint32
	syncGroup sync.WaitGroup
	server *http.Server
	userProvider userProvider
	permissionProvider permissionProvider
	ownerProvider ownerProvider
	resources map[string] resourceObject
}

/*
	Run will start the service server and block until its shutdown
*/
func (service *Service) Run() {
	service.syncGroup.Add(1)
	service.reqsInProcess = 0
	if service.Config.https {
		//listen on HTTPS port
		httpsListener, err := newHttpsListener(
			"",
			service.Config.networkConfig.HttpsPort,
			service.shutdownSignal,
			service.server.TLSConfig,
		)
		if err != nil {
			panic(fmt.Errorf("Could not start HTTPS listener: %s", err))
		}
		err = service.server.Serve(httpsListener)
	} else {
		//listen on HTTP port
		httpListener, err := newHttpListener(
			"",
			service.Config.networkConfig.HttpPort,
			service.shutdownSignal,
		)
		if err != nil {
			panic(fmt.Errorf("Could not start HTTP listener: %s", err))
		}
		err = service.server.Serve(httpListener)
	}
	service.syncGroup.Done()
	service.syncGroup.Wait()
}

/*
	createTransaction returns a transaction object for the internal database.
*/
func (service *Service) createTransaction() transaction {
	return transaction {
		database: service.database,
	}
}

/*
	CreateUser registeres a new user account identified by the given username
	and returns its generated unique identifier.
	The given password will later be associated with the given username
	and encrypted using a cryptographic hash function.
	An error will be returned in either of the cases:
	1) Either username, password or both do not match minimal requirements.
	2) The given username is already taken by another account.
*/
func (service *Service) CreateUser(
	username string,
	password string,
) (
	assignedId Identifier,
	err error,
) {
	txn := service.createTransaction()
	txn.Begin()
	defer func() {
		if err != nil {
			txn.Rollback()
		} else {
			txn.Commit()
		}
	}()
	assignedId = GenerateUniqueIdentifier()
	//verify username
	if len(username) < 2 {
		return assignedId, fmt.Errorf(
			"Username ('%s'(%d)) is too short",
			username,
			len(username),
		)
	}
	//verify username is not taken by another account
	_, err = service.userProvider.FindUserByUsername(username)
	if err == nil {
		return assignedId, fmt.Errorf(
			"Username ('%s') is no longer available",
			username,
		)
	}
	//verify password
	if len(password) < 2 {
		return assignedId, fmt.Errorf(
			"Password ('%s'(%d)) is too short",
			password,
			len(password),
		)
	}
	//encrypt password
	encryptedPassword, err := bcrypt.GenerateFromPassword(
		[]byte(password),
		0,
	)
	if err != nil {
		panic(fmt.Errorf(
			"Could not hash password ('%s'): %s",
			password,
			err,
		))
	}
	//prepare database operation
	statement, err := service.database.Prepare(`
		INSERT INTO users
		(id, username, password) VALUES (?,?,?)
	`)
	defer statement.Close()
	if err != nil {
		panic(fmt.Errorf(
			"Could not prepare insertion statement: %s",
			err,
		))
	}
	//register in database
	_, err = statement.Exec(
		assignedId.String(),
		username,
		encryptedPassword,
	)
	if err != nil {
		panic(fmt.Errorf(
			"Could not register account in database: %s",
			err,
		))
	}
	return assignedId, nil
}

/*
	FindUserById returns a user account identified by the given identifier.
	An error will be returned in case no user was found.
*/
func (service *Service) FindUserById(
	identifier Identifier,
) (
	account UserAccount,
	err error,
) {
	return service.userProvider.FindUserById(identifier)
}

/*
	FindUserByUsername returns a user account identified by the given username.
	An error will be returned in case no user was found.
*/
func (service *Service) FindUserByUsername(
	username string,
) (
	account UserAccount,
	err error,
) {
	return service.userProvider.FindUserByUsername(username)
}

/*
	GetResourceIdentifier returns a resource identifier object
	representing the resource given its identifier and path of variable values.
	An error will be returned in the following 3 cases:
	1) the identifier is not registered therefore invalid.
	2) one or multiple required variable values are missing.
	3) one or multiple required variable values do not match assigned pattern.
*/
func (service *Service) GetResourceIdentifier(
	identifier string,
	variables map[string] string,
) (
	resourceId ResourceIdentifier,
	err error,
) {
	resourceObj, exists := service.resources[identifier]
	if !exists {
		return resourceId, fmt.Errorf(
			"Resource identified by '%s' not found",
			identifier,
		)
	}
	//trace back
	hasParent := true
	for hasParent != false {
		segment := resourceIdSegment {
			identifier: resourceObj.Identifier(),
			name: resourceObj.Name(),
		}
		switch resourceObj.(type) {
		case *staticResource:
			segment.typ = STATIC
		case *variableResource:
			segment.typ = VARIABLE
			segment.value = variables[segment.identifier]
			if len(variables[segment.identifier]) < 1 {
				//value for variable resource missing
				return resourceId, fmt.Errorf(
					"Missing value for variable segment '%s'",
					segment.identifier,
				)
			}
			if !resourceObj.(*variableResource).MatchPattern(segment.value) {
				//given doesnt match enforced pattern
				return resourceId, fmt.Errorf(
					"Wrong value for variable segment '%s'",
					segment.identifier,
				)
			}
		}
		resourceId.path = append(
			[]resourceIdSegment{segment},
			resourceId.path...
		)
		parentId := resourceObj.Parent()
		resourceObj = service.resources[parentId]
		if parentId == "root" || parentId == "" {
			hasParent = false
		}
	}
	return resourceId, nil
}

/*
	AssignOwner transfers ownership of the given resource
	to the given user. The new owner will be defined in case
	there is yet no one owning the given resource.
*/
func (service *Service) AssignOwner(
	resourceId ResourceIdentifier,
	userId Identifier,
) (
	err error,
) {
	userIdStr := userId.String()
	resourceIdStr := resourceId.Serialize()
	txn := service.createTransaction()
	defer func() {
		if err != nil {
			txn.Rollback()
		} else {
			txn.Commit()
		}
	}()
	txn.Begin()

	//verify resource entry exists
	verifyExistance, err := service.database.Prepare(`
		SELECT str_id FROM resources WHERE str_id = ?
	`)
	defer verifyExistance.Close()
	if err != nil {
		return fmt.Errorf(
			"Failed registering owner in database: %s",
			err,
		)
	}
	rows, err := verifyExistance.Query(resourceIdStr)
	defer rows.Close()
	if err != nil {
		return fmt.Errorf(
			"Failed registering owner in database: %s",
			err,
		)
	}
	rowCount := 0
	for rows.Next() {
		rowCount++
	}

	switch {
	case rowCount < 1:
		//insert
		insertResWithOwner, err := service.database.Prepare(`
			INSERT INTO resources (owner_id, str_id) VALUES (?,?)
		`)
		defer insertResWithOwner.Close()
		if err != nil {
			return fmt.Errorf(
				"Failed registering owner in database: %s",
				err,
			)
		}
		_, err = insertResWithOwner.Exec(
			userIdStr,
			resourceIdStr,
		)
		if err != nil {
			return fmt.Errorf(
				"Failed registering owner in database: %s",
				err,
			)
		}
	case rowCount > 0:
		//update
		updateOwner, err := service.database.Prepare(`
			UPDATE resources SET owner_id = ?
			WHERE str_id = ?;
		`)
		defer updateOwner.Close()
		if err != nil {
			return fmt.Errorf(
				"Failed registering owner in database: %s",
				err,
			)
		}
		_, err = updateOwner.Exec(
			userIdStr,
			resourceIdStr,
		)
		if err != nil {
			return fmt.Errorf(
				"Failed registering owner in database: %s",
				err,
			)
		}
	}
	return nil
}

/*
	AssignPermissions assigns provided permissions
	for the given user on the given resource.
	Already registered entries will be overwritten.
	
	NOTICE: The user argument accepts both a certain user identifier
	or an abstract user like other users (OTHERS) and guests (GUESTS).

	CAUTION: passing user identifier of unsupported type will cause panic!
*/
func (service *Service) AssignPermissions(
	resourceId ResourceIdentifier,
	user interface{},
	permissions Permissions,
) (
	err error,
) {
	userId := verifyTargetUser(user)
	resourceIdStr := resourceId.Serialize()

	//verify resource entry exists
	txn := service.createTransaction()
	defer func() {
		if err != nil {
			txn.Rollback()
		} else {
			txn.Commit()
		}
	}()
	txn.Begin()
	verifyExistance, err := service.database.Prepare(`
		SELECT str_id FROM resources WHERE str_id = ?
	`)
	defer verifyExistance.Close()
	if err != nil {
		return fmt.Errorf(
			"Failed registering permissions in database: %s",
			err,
		)
	}
	defer verifyExistance.Close()
	rows, err := verifyExistance.Query(resourceIdStr)
	defer rows.Close()
	if err != nil {
		return fmt.Errorf(
			"Failed registering permissions in database: %s",
			err,
		)
	}
	rowCount := 0
	for rows.Next() {
		rowCount++
	}

	if rowCount < 1 {
		//insert resource entry first
		insertResEntry, err := service.database.Prepare(`
			INSERT INTO resources (str_id) VALUES (?)
		`)
		defer insertResEntry.Close()
		if err != nil {
			return fmt.Errorf(
				"Failed registering permissions in database: %s",
				err,
			)
		}
		_, err = insertResEntry.Exec(resourceIdStr)
		if err != nil {
			return fmt.Errorf(
				"Failed registering permissions in database: %s",
				err,
			)
		}
	}

	//insert permissions entry
	insertPermissions, err := service.database.Prepare(`
		INSERT OR REPLACE INTO resource_permissions
		(resource_id, user_id, permissions)
		VALUES (
			(SELECT id FROM resources WHERE str_id = ?),
			?,?
		)
	`)
	defer insertPermissions.Close()
	if err != nil {
		return fmt.Errorf(
			"Failed registering permissions in database: %s",
			err,
		)
	}
	_, err = insertPermissions.Exec(
		resourceIdStr,
		userId,
		permissions.Serialize(),
	)
	if err != nil {
		return fmt.Errorf(
			"Failed registering permissions in database: %s",
			err,
		)
	}

	return nil
}

/*
	RevokePermissions revokes permission entries for 
	for the given user on the given resource.
	
	NOTICE: The user argument accepts both a certain user identifier
	or an abstract user like other users (OTHERS) and guests (GUESTS).

	CAUTION: passing user identifier of unsupported type will cause panic!
*/
func (service *Service) RevokePermissions(
	resourceId ResourceIdentifier,
	user interface{},
) (
	err error,
) {
	userId := verifyTargetUser(user)
	deleteEntry, err := service.database.Prepare(`
		DELETE FROM resource_permissions
		WHERE resource_id = (SELECT id FROM resources WHERE str_id = ?)
		AND user_id = ?
	`)
	defer deleteEntry.Close()
	if err != nil {
		return fmt.Errorf(
			"Failed to delete permission entry in database: %s",
			err,
		)
	}
	defer deleteEntry.Close()
	rows, err := deleteEntry.Query(resourceId.Serialize(), userId)
	defer rows.Close()
	if err != nil {
		return fmt.Errorf(
			"Failed to delete permission entry in database: %s",
			err,
		)
	}
	rowCount := 0
	for rows.Next() {
		rowCount++
	}

	return nil
}

/*
	GetPermissionsFor returns directly assigned permissions and
	inheritance flags for the user and resource.
	Its not recommended to use this method to get actual permissions
	of a user for the final resource as it doesnt resolve permissions
	by taking the inherited ones into account,
	to resolve final permissions use ResolvePermissionsFor instead.

	CAUTION: passing user identifier of unsupported type will cause panic!
*/
func (service *Service) GetPermissionsFor(
	resourceId ResourceIdentifier,
	user interface{},
) (
	permissions Permissions,
	err error,
) {
	userId := verifyTargetUser(user)
	return service.permissionProvider.GetPermissionsFor(resourceId, userId)
}

/*
	ResolvePermissionsFor returns actual permissions of the given user
	for the given resource resolving inherited permissions.

	CAUTION: passing user identifier of unsupported type will cause panic!
*/
func (service *Service) ResolvePermissionsFor(
	resourceId ResourceIdentifier,
	user interface{},
) (
	isOwner bool,
	permissions Permissions,
	err error,
) {
	if user == nil {
		user = GUESTS
	}
	userId := verifyTargetUser(user)

	resolvePermissions := func (
		currentResource ResourceIdentifier,
		user string,
	) (
		permissions Permissions,
		err error,
	) {
		for {
			permissions, err = service.
				permissionProvider.
				GetPermissionsFor(currentResource, user)
			if err != nil {
				switch err.(type) {
				case NotFoundError:
					//inherits permissions?
					defaultPermissions := service.
						resources[currentResource.Identifier()].
						DefaultPermissions()
					switch user {
					case "o":
						if !defaultPermissions.Inheritance.OtherUserPermissions {
							return permissions, NotFoundError {
								message: "Default user permissions not found",
							}
						}
					case "g":
						if !defaultPermissions.Inheritance.GuestPermissions {
							return permissions, NotFoundError {
								message: "Guest permissions not found",
							}
						}
					default:
						if !defaultPermissions.Inheritance.UserPermissions {
							return permissions, NotFoundError {
								message: "User permissions not found",
							}
						}
					}
					//switch to parent, try to find inherited permissions
					currentResource, err = currentResource.Parent()
					if err != nil {
						//no further parent
						return permissions, NotFoundError {
							message: "Permissions not found",
						}
					}
					continue
				default:
					return permissions, fmt.Errorf(
						"Could not get permissions for '%s':'%s': %s",
						user,
						currentResource.String(),
						err,
					)
				}
			}
			//found permissions
			break
		}
		return permissions, nil
	}

	resolveOwnership := func (
		currentResource ResourceIdentifier,
	) (
		owner Identifier,
		err error,
	) {
		for {
			owner, err = service.ownerProvider.GetOwnerOf(currentResource)
			if err != nil {
				switch err.(type) {
				case NotFoundError:
					//inherits owner?
					if !service.resources[currentResource.Identifier()].
						DefaultPermissions().
						Inheritance.Owner {
						return owner, NotFoundError {
							message: "Owner not found",
						}
					}
					//switch to parent, try to find inherited owner
					currentResource, err = currentResource.Parent()
					if err != nil {
						//no further parent
						return owner, NotFoundError {
							message: "Owner not found",
						}
					}
					continue
				default:
					return owner, fmt.Errorf(
						"Could not get owner for '%s': %s",
						currentResource.String(),
						err,
					)
				}
			}
			//found owner
			break
		}
		return owner, nil
	}

	switch user.(type) {
	case TargetUser:
		switch user {
		case OTHERS:
			permissions, err := resolvePermissions(resourceId, "o")
			if err != nil {
				switch err.(type) {
				case NotFoundError:
					permissions = service.
						resources[resourceId.Identifier()].
						DefaultPermissions().
						UserPermissions
					return isOwner, permissions, nil
				default:
					return isOwner, permissions, fmt.Errorf(
						"Could not resolve default user permissions: %s",
						err,
					)
				}
			}
			return false, permissions, nil
		case GUESTS:
			permissions, err := resolvePermissions(resourceId, "g")
			if err != nil {
				switch err.(type) {
				case NotFoundError:
					permissions = service.
						resources[resourceId.Identifier()].
						DefaultPermissions().
						GuestPermissions
					return isOwner, permissions, nil
				default:
					return isOwner, permissions, fmt.Errorf(
						"Could not resolve guest permissions: %s",
						err,
					)
				}
			}
			return false, permissions, nil
		}
	case *Identifier:
		//is owner?
		actualOwner, err := resolveOwnership(resourceId)
		if err != nil {
			switch err.(type) {
			case NotFoundError:
				isOwner = false
			default:
				return isOwner, permissions, fmt.Errorf(
					"Could not resolve ownership: %s",
					err,
				)
			}
		}

		if actualOwner.String() == userId {
			isOwner = true
		}
		//is mentioned?
		permissions, err = resolvePermissions(resourceId, userId)
		if err != nil {
			switch err.(type) {
			case NotFoundError:
				//not mentioned
				if isOwner {
					permissions.AllowAll()
					return isOwner, permissions, nil
				}
				permissions, err = resolvePermissions(resourceId, "o")
				if err != nil {
					switch err.(type) {
					case NotFoundError:
						//permissions for other users not defined
						permissions = service.
							resources[resourceId.Identifier()].
							DefaultPermissions().
							UserPermissions
						return isOwner, permissions, nil
					default:
						return isOwner, permissions, fmt.Errorf(
							"Could not resolve ownership: %s",
							err,
						)
					}
				}
			default:
				return isOwner, permissions, fmt.Errorf(
					"Could not resolve ownership: %s",
					err,
				)
			}
		}
	}
	return isOwner, permissions, nil
}

/*
	Shutdown gracefully stops the service
*/
func (service *Service) Shutdown() {
	close(service.shutdownSignal)
	service.shutdownRequested = true
}



